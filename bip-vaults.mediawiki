<pre>
  BIP: xxxx
  Layer: Consensus (soft fork)
  Title: OP_VAULT
  Author: James O'Beirne <vaults@au92.org>
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx
  Status: Draft
  Type: Standards Track
  Created: 2020-02-03
  License: BSD-3-Clause
  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment
</pre>


== Introduction ==

=== Abstract ===

This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and
<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. 
These opcodes allow users to enforce a delay period before designated coins may
be spent to an arbitrary destination, with the exception of a prespecified
"recovery" path. At any time prior to final withdrawal, the coins can be spent to
the prespecified path.


=== Motivation ===

The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to
significant effort to secure their private keys, and hope that once provisioned
their custody system does not yield to any number of evolving and
persistent threats. Users have little means to intervene once compromise is
detected. This proposal introduces a mechanism that significantly
mitigates the worst-case outcome of key compromise: coin loss.

Introducing a way to intervene during unexpected spends allows users to
incorporate highly secure key storage methods or unusual fallback strategies
that are only exercised in the worst case, and which may otherwise be
operationally prohibitive. The goal of this proposal is to make this strategy
usable for custodians of any size with minimal complication.

==== Example uses ====

An individual custodying Bitcoin uses the common "single signature and
passphrase" configuration with a hardware wallet. They are concerned about the
risk associated with relying on a single manufacturer for key management as
well as physical access to the hardware, so they generate a new key that is
highly secure, but would be impractical for daily use. For example the key
could be generated in some analog fashion, or on an old computer (with added
entropy) that is then destroyed, with the private key replicated only in paper
form. Or the key could be a 2-of-3 multisig using devices from different
manufacturers. Perhaps the key is geographically distributed.

This individual can use <code>OP_VAULT</code> to make use of the highly secure
key as the unlikely recovery path, while using their existing signing procedure
as the withdrawal trigger key, with a configured spend delay of 1 day. They can
run software on their mobile device that monitors the blockchain for spends of
the vault outpoints.

If the vaulted coins move in an unexpected way, they can immediately sweep them
to the highly secure but impractical recovery path, but spending the coins on a
daily basis works in the same way it did prior to vaulting - aside from the
spend delay.

The recovery key could be any number of things: a 2-of-3 multisig with keys
that live on different devices. It could be a 3-of-5 with socially distributed
keys. It could be a Taproot construction that incorporates one of these methods
along with a time-delayed fallback to an "easier" recovery method, in case the
highly secure key winds up being ''too'' highly secure.

Institutional custodians of Bitcoin would likely use vaults in similar fashion.

===== Avoiding the hostage situation =====

This proposal uniquely provides a solution to the "hostage situation;" by
setting the spend delay to, say, a week, and using as the recovery path a
script that enforces a longer relative timelock, the owner of the vault can
prove that he is unable to access its value immediately. To the author's
knowledge, this is the only way to configure this defense without rolling
timelocked coins for perpetuity or relying on a trusted third party.

== Goals ==

[[File:bip-VAULT/vaults-Basic.png|frame|center]]

Vaults in Bitcoin have been discussed formally since 2016
([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of
having a configurable delay period with recovery capability in light of an
unexpected spend has been widely recognized, but vault implementations that are
usable given the existing consensus rules have a number of significant practical
shortcomings.

These include:
* the necessity to generate and securely delete ephemeral keys, which are used to emulate the vault covenant,
* the necessity to precommit to amounts and withdrawal patterns,
* the necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,
* the necessity to precommit to a particular fee management technique or wallet,
* the danger of coin loss if a vault address is reused,
* the necessity to store for perpetuity transaction data that represents the "bearer asset" of the vault, and
* the necessity to perform the vault creation ceremony each time a new balance is to be vaulted.

The deployment of a "precomputed" covenant mechanism like
[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY]
or [https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT]
would both remove the necessity to use an ephemeral key, since the covenant is
enforced on-chain, and lessen the burden of sensitive data storage, since the necessary
transactions can be generated from a set of compact parameters. 

However, all the related limitations of precomputation apply: amounts,
destinations, and fee management are all fixed. Funds must flow through a static
intermediary to their final destination. Batch operations, which may be vital
for successful recovery during fee spikes or short spend delay, are not possible.

[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]

Having a "general" covenant mechanism that can encode arbitrary transactional
state machines would allow us to solve these issues, but at the cost of complex
and large scripts that would probably be duplicated many times over in the
blockchain. The particular design and deployment timeline of such a general
framework is also uncertain.

This proposal intends to address the problems outlined above. It attempts to
implement a delay period/recovery path use with minimal transactional and
operational overhead.

The design goals of the proposal are:

* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. 

* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.

* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.

* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at unvault time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.

* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.

Along with basic safety considerations (e.g. not being vulnerable to pinning)
and a desire for concision, both in terms of the number of outputs
created as well as script sizes.

This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. It will benefit from, but does not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].

== Design ==

=== Vault lifecycle ===

[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]

The vault has a number of stages, some of them optional:

* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.

* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).

* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.

* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.


=== Vault parameters ===

==== ''recovery-params'' ====

The recovery parameters dictate both where funds can be swept to during a
recovery, and what kind of authorization (if any) is needed to initiate a
recovery. It is specified in the form 

<source>
<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]
</source>

The first component commits to the destination that vault funds can be swept to
at any point prior to the finalization of a withdrawal.

The recovery scriptPubKey would usually correspond to a spending script that is
inconvenient to exercise but highly secure.

The second component, the recovery authorization scriptPubKey, is optional. It
is a raw scriptPubKey that, if specified, must be satisfied to allow the input
to be recovered. The benefit of using this parameter will be discussed later.
If this component is not given, the de facto "authorization" is the reveal of
the <code><recovery sPK tagged hash></code> preimage.

Vaults which share the same recovery path can always be swept in batch operations,
which is an important practical aspect of managing large numbers of vaults.

==== ''spend-delay'' ====

The spend delay dictates the duration of blocks or time which must
elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the
withdrawal target outputs. Encoded as the least significant 23 bits of a
[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style
relative locktime.

==== Trigger key ====

The trigger key, committed to with a tagged hash, is used to authorize the ''trigger transaction'' - an on-chain declaration to attempt a withdrawal to a certain set of target outputs.

This functions as the "normal" spending key, but if an attacker obtains access
to this key, the outcome is not catastrophic: any withdrawal attempt can be
interrupted (within the spend delay) and swept to the recovery path. 

The trigger key can be an arbitrary scriptPubKey so long as it represents a
valid witness program. <code>OP_VAULT</code> outputs which have the same
recovery params and spend delay can be spent into the same
<code>OP_UNVAULT</code> output for a batched withdrawal process. 

Even when vault outputs do not share recovery params, multiple such
recovery-incompatible vaults can be grouped together (each with their own
<code>OP_UNVAULT</code> output) within a single trigger transaction, along with
unrelated inputs and outputs, so that fee management is shared.


==== ''target-outputs-hash'' ====

An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.


== Specification ==

The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and
<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the
<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.

=== Creating an <code>OP_VAULT</code> output ===

In order to vault coins, they must be spent into a witness v1<ref>'''Can <code>OP_VAULT</code> be used with a future witness version (greater than 1)?''' Yes, however use of yet to be defined witness versions is discouraged, since such a usage makes the coins spendable by anyone.</ref> <code>scriptPubKey</code> 
that contains a Tapscript spending condition of the form

<source>
<recovery-params> <spend-delay> <trigger-sPK-hash> OP_VAULT
</source>

The validation of these parameters at spend time are covered in the next section.

Typically, the internal key for the vault taproot output will be specified so
that it is controlled by the same descriptor as the recovery path, which
facilitates another (though probably unused) means of recovering the vault
output to the recovery path. This has the potential advantage of recovering the
coin without ever revealing it was a vault. 

Otherwise, the internal key can be chosen to be an unspendable NUMS point to
force tapscript execution of the <code>OP_VAULT</code> specification.


=== Spending an <code>OP_VAULT</code> output into a trigger transaction ===

To start the withdrawal process for vaulted coins, <code>OP_VAULT</code>
outputs can be spent into a trigger transaction which creates a corresponding
<code>OP_UNVAULT</code> output. This publicly declares the intent to spend the
vaulted coins to a specific non-recovery destination. The trigger transaction
may also have a "revault" output, which redeposits some partial balance of the vault
back into its original <code>OP_VAULT</code> scriptPubKey.

Spending an <code>OP_VAULT</code> in such a way is validated as follows.

==== Witness program ====

When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,
<code>0xbb</code>), the witness program is pushed onto the stack for the
followng result (stack shown top to bottom):

<source>
OP_VAULT  (<-- being evaluated)
<trigger-sPK-hash> 
<spend-delay> 
<recovery-params> 
</source>

where

* <code><recovery-params></code> is a variable length data push, consisting of two components:
*# a 32 byte tagged hash, committing to the scriptPubKey which coins may be recovered to 
*#* <code>tagged_hash("VaultRecoverySPK", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].
*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. 
*#* This optional parameter changes the allowable structure of recovery transactions.
** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.
** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.

* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) 
** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.
** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.

* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output 
** <code>tagged_hash("VaultTriggerSPK", spk)</code>, per BIP-0340.
** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. 
** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.

==== Witness stack ====

After the <code>OP_VAULT</code> witness program has been pushed
and evaluated per the steps in the previous section, there must be at least 4
items remaining on the stack (shown top to bottom):

<source>
<trigger-vout-idx>
<target-outputs-hash>
<trigger-sPK>
<trigger witness stack item 1> [...] <item n>
</source>

If the witness stack consists of fewer than four items the script MUST fail and
terminate immediately.

(Note: in practice, the witness stack will have included the other items necessary to reveal 
a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)

The items on the stack must be validated as follows:

* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.
** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.
*** Validation rules for this output are described below.
** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.
** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.

* <code><target-outputs-hash></code> is a 32 byte data push.
** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>
** If this value is not 32 bytes, the script MUST fail and terminate immediately.

* <code><trigger-sPK></code> is a variable length data push.
** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.
** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.
*** Verify <code>tagged_hash("VaultTriggerSPK", <trigger-sPK>) == <trigger-sPK-hash></code>
** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.

* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.
** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.
** (This validates that the withdrawal trigger has been authorized.)

==== Transaction outputs validation ====

Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.

First, we must check for a ''revault output'': an output in the transaction whose
scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being
spent. Its presence is optional.

For each vault input citing a particular <code><trigger-vout-idx></code>, the output 
located at <code>vout[<trigger-vout-idx>]</code> (the "trigger output") must:

* have as its scriptPubKey a witness program version 1 with a single <code>OP_UNVAULT</code> tapscript, having the internal key <code>lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Design BIP-0341].<ref>'''Why must the OP_VAULT taproot use a NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>
** If the witness program has a version less than 1, the script MUST fail and terminate immediately.
** If the scriptPubKey of the output does not match the expected scriptPubKey, as computed by creating a taproot output using the cited NUMS point and a single tapscript spend condition of the form<br /><code><recovery-params-from-stack> <spend-delay-from-stack> <target-outputs-hash-from-stack> OP_UNVAULT</code>,<br />the script MUST fail and terminate immediately.
** Witness versions greater than 1 are allowed for upgradeability.

* If there does not exist a revault output in the transaction for this input:
** the <code>nValue</code> of the trigger output must equal the sum of all vault inputs which cite it as their corresponding trigger output.
*** If these values are not equal, the script MUST fail and terminate immediately.
* else (if there does exist a revault output for this input):
** the <code>nValue</code>s of the trigger output and the revault output must sum to the sum of all vault inputs which both 
*** cite this trigger output as the trigger-vout-idx and 
*** have a scriptPubKey identical to the revault output's.
** If these values are not equal, the script MUST fail and terminate immediately.

If none of the conditions above results in a failure of the script interpreter, the 
stack will consist of a single true value (<code>0x01</code>).

The above amount check can be expressed in Python as:

<source lang="python">

spending_tx: CTransaction
vault_inputs: [CTxIn] = [inp for inp in spending_tx.vin if inp.is_OP_VAULT]

"Where we'll accumulate the expected totals for each vault input."
vault_totals_for_outputs: dict[(int, int), int] = defaultdict(0)

"Build the expected totals."
for vault_in in vault_inputs:
    maybe_revault_idx = find_revault_for_vault(vault_in)
    vault_total_for_outputs[(vault_in.trigger_vout_idx, maybe_revault_idx)] += vault_in.nValue


"Check the expected totals against outputs."
for (out_idx, maybe_revault_idx), expected_amount in vault_totals_for_outputs.items():
    total = spending_tx.vout[out_idx].nValue

    if maybe_revault_idx:
        total += spending_tx.vout[maybe_revault_idx]

    if total != expected_amount:
        FAIL_AND_TERMINATE_SCRIPT()
    
    
def find_revault_for_vault(vault_in) -> int:
    """Find the index of a revault output for a particular vault input, if one exists."""
    for i, out in enumerate(spending_tx.vout):
        if out.scriptPubKey == vault_in.scriptPubKey:
            return i
    return None
</source>

==== Note: batching and fee management ====

Multiple vault inputs sharing <code><recovery-params></code> and <code><spend-delay></code> 
can be spent into the same <code>OP_UNVAULT</code> output (a batched withdrawal) regardless of their <code><trigger-sPK-hash></code> parameter.

Since <code>SIGHASH_DEFAULT</code> can be used to sign the trigger authorization, unrelated inputs and outputs can be included, possibly to facilitate fee management or the batch withdrawal of incompatible vaults.

=== Spending an <code>OP_UNVAULT</code> output to complete a withdrawal ===

Once the delay specified by the <code><spend-delay></code> parameter has elapsed (per the same <code>CheckSequence(...)</code> algorithm used for [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112]), an <code>OP_UNVAULT</code> output can be spent into a transaction that having the set of outputs compatible with the <code><target-outputs-hash></code> parameter.


==== Witness program ====

When evaluating <code>OP_UNVAULT</code> (<code>OP_SUCCESS188</code>,
<code>0xbc</code>), the witness program is pushed onto the stack for the
following result (stack shown top to bottom):

<source>
OP_UNVAULT  (<-- being evaluated)
<target-outputs-hash> 
<spend-delay> 
<recovery-params> 
</source>

where

* <code><recovery-params></code> is validated exactly as described in [[#witness-program|the above section]].
* <code><spend-delay></code> is validated exactly as described in [[#witness-program|the above section]], with the following additional checks:
** If the input's relative timelock check, as described in [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112] (using this value as "the top item on the stack") fails, the script MUST fail and terminate immediately.
* <code><target-output-hash></code> is a 32 byte data push.
** If it is not equal to 32 bytes, the script MUST fail and terminate immediately.
** If <code>target_outputs_hash(spending_tx.vout) != <target-output-hash></code> per the algorithm defined below, the script MUST fail and terminate immediately.

<source lang="python">
def target_outputs_hash(vout: [CTxOut]) -> bytes:
    return hash256(b"".join(serialize_txout(out) for out in vout))

def serialize_txout(txo: CTxOut) -> bytes:
    spk: bytes = txo.scriptPubKey
    return struct.pack("<q", txo.nValue) + ser_compact_size(len(spk)) + spk
</source>

If the above conditions do not fail, a single true value (<code>0x01</code>) is pushed to the stack.

(Note: in practice, the witness stack will have included the other items necessary to reveal 
a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)

(Note: multiple unrelated <code>OP_UNVAULT</code> outputs can be used towards the same withdrawal transaction provided that they share identical <code><target-outputs-hash></code> parameters. This facilitates batched withdrawals.)

==== Witness stack ====

When spending an <code>OP_UNVAULT</code> input into a withdrawal target, no witness stack is required.

=== Spending into a recovery transaction ===

At any point prior to the confirmation of a withdrawal transaction, <code>OP_VAULT</code>/<code>OP_UNVAULT</code>-encumbered outputs can be spent into a recovery transaction. Script execution works identically for both types of outputs.

[[File:bip-VAULT/batch-sweep.drawio.png|frame|center]]

==== Witness program ====

When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,
<code>0xbb</code>) for recovery, the witness program is parsed exactly as in [[#witness-program|the earlier section]].

When evaluating <code>OP_UNVAULT</code> (<code>OP_SUCCESS188</code>,
<code>0xbc</code>) for recovery, the witness program is parsed exactly as in [[#witness-program-1|the earlier section]].

==== Witness stack ====

''(Note: to summarize, <code><recovery-params></code> is decomposed into two parts: the first 32 bytes (''recovery sPK hash'') and the remaining bytes (the ''recovery authorization sPK''). Only the first component is required.)''

Once the <code>OP_[UN]VAULT</code> witness programs are parsed, the following validation is performed:

* If an output (the "recovery output") does not exist with a tagged-hash matching the recovery sPK hash, the script MUST fail and terminate immediately.
** Verify <code>any(tagged_hash("VaultRecoverySPK", out.scriptPubKey) == recovery_sPK_hash for out in spending_tx.vout)</code>
* If the recovery output does not have an <code>nValue</code> equal to the sum of all inputs with a corresponding recovery sPK hash, the script MUST fail and terminate immediately.
* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a "rebundled" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>
*# the input must be marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], or
*# the version of the recovery transaction must have an nVersion equal to 3.

The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.

* If the ''recovery authorization sPK'' is not null:
** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.
** (This validates that the recovery has been authorized.)
* else (if the recovery is allowed to be unauthorized):
** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.
** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>


(Note: the above rules imply that if all inputs have a recovery authorization sPK specified, the structure of the recovery transaction is "free form," and the only requirement is that for each <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input, there exists a compatible ''recovery output'' which preserves its full <code>nValue</code>.)

If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.

== Considerations for end use ==

=== Recovery authorization ===

When configuring a vault, the user must decide if they want to have the recovery process gated by the optional recovery authorization scriptPubKey. The choice is left to the user because it entails trade-offs.

==== Unauthorized recovery ====

Unauthorized recovery simplifies vault use in that recovery never requires additional information aside from the location of the vault outpoints and the recovery path - the "authorization" is simply the reveal of the recovery path. 

But because this reveal is the only authorization necessary to spend the vault coins to recovery, the user must expect to recover all such vaults at once, since an observer can replay this recovery (provided they know the outpoints).

Additionally, unauthorized recovery across multiple distinct recovery paths cannot be batched, and fee control is more constrained: because the output structure is limited for unauthorized recovery, fee management relies either on inputs which are completely spent to fees or the use of the optional ephemeral anchor and package relay.

==== Authorized recovery ====

With authorized recovery, the user must keep track of an additional piece of information: how to solve the recovery authorization scriptPubKey when recovery is required. If this key is lost, the user will be unable to initiate the recovery process for their coins. If an attacker obtains the recovery key, they may grief the user during the recovery process by constructing a low fee rate recovery transaction and broadcasting it (though they will not be able to pin because of the replaceability requirement on recovery transactions).

However, authorized recovery configurations have significant benefits. Batched recoveries are possible for vaults with otherwise incompatible recovery parameters. Fee management is much more flexible, since authorized recovery transactions are "free form" and unrelated inputs and outputs can be added, potentially to handle fees.

==== Recommendation: use a simple, offline recovery authorization key seed ====

The benefits of batching and fee management that authorized recovery provides are significant. If the recovery authorization key falls into the hands of an attacker, the outcome is not catastrophic, whereas if the user loses their recovery authorization key as well as their trigger key, the result is likely coin loss. Consequently, the author's recommendation is to use a simple seed for the recovery authorization key that can be written down offline and replicated. 

Note that the recovery authorization key '''is not''' the recovery path key, and
this is '''much different''' than any recommendation on how to generate the
recovery path key itself.

=== Address reuse and recovery ===

When creating a vault, four factors affect the resulting P2TR address:
# The internal key (likely related to your recovery wallet)
# The recovery parameters
# The spend delay
# The trigger scriptPubKey

Aside from the spend delay, the end user has the option of varying the other three parameters along descriptors in order to avoid reusing vault addresses without affecting key management.

Worth noting is that when using unauthorized recovery, the reveal of the recovery scriptPubKey will allow any observer to initiate the recovery process for any vault with matching recovery params, provided they are able to locate the vault outpoints. As a result, it is recommended to expect that '''all outputs sharing an identical unauthorized <code><recovery-params></code> should be recovered together'''.

This situation can be avoided with a comparable key management model by varying the generation of each vault's recovery scriptPubKey along a single descriptor, but note that (when configured for unauthorized recovery), this will prevent batched recovery.

==== Recommendation: vary the internal key ====

The recommended mode of use is to keep recovery parameters identical across vaults which should be recovered in batch, but vary the internal key for each vault output along a single descriptor so that no address reuse is necessary.

==== Recommendation: generate new recovery addresses for new trigger keys ====

If using unauthorized recovery, it is recommended that you do not share literal recovery paths
across separate trigger keys. If one trigger key is compromised, that will necessitate the (unauthorized)
recovery of all vaults with that trigger key, which will reveal the recovery path preimage. This
means that an observer might be able to initiate recovery for vaults controlled by an uncompromised
trigger key.

==== Fee management ====

Fees can be managed in a variety of ways, but it's worth noting that both trigger and recovery transactions must preserve the total value of vault inputs, so vaulted values cannot be repurposed to pay for fees. This does not apply to the withdrawal transaction, which can allocate value arbitrarily.

In the case of vaults that use recovery authorization, all transactions can "bring their own fees" in the form of unrelated inputs and outputs. These transactions are also free to specify ephemeral anchors, once the related relay policies are deployed. This means that vaults using recovery authorization have no dependence on the deploy of v3 relay policy.

In the case of vaults that do not use recovery authorization, the recovery transaction relies on the use of either fully-spent fee inputs or an ephemeral anchor output. This means that vaults which do not use recovery authorization are essentially dependent on v3 transaction relay policy being deployed.

=== Batching ===

Vaults with the same recovery-params and spend-delay can be triggered into the same <code>OP_UNVAULT</code> output.

Trigger transactions can act on multiple incompatible vaults, provided each group has a compatible <code>OP_UNVAULT</code> output.

Vaults with the same recovery path scriptPubKey can be recovered into the same output.

Recovery-incompatible vaults which have authorized recovery can be recovered in the same transaction, and benefit from sharing common fee management.

=== Watchtowers ===

The value of vaults is contingent upon having monitoring in place that will alert the owner when unexpected spends are taking place. This can be done in a variety of ways, with varying degrees of automation and trust in the watchtower.

In the maximum-trust case, the watchtower can be fully aware of all vaulted coins and has the means to initiate the recovery process if spends are not pre-reported to the watchtower.

In the minimum-trust case, the user can supply a probabilistic filter of which coins they wish to monitor; the watchtower would then alert the user if any coins matching the filter move, and the user would be responsible for ignoring false positives and handling recovery initiation.

=== Script descriptors ===

Script descriptors for vault-related outputs will be covered in a subsequent BIP.


== Deployment ==

It is anticipated that deployment will happen in the same way [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Deployment that BIP-0341 was deployed]. Parameters to be determined.


== Rationale ==

<references />

== Transaction examples ==


== Acknowledgements ==

The author would like to thank

* AJ Towns for discussion, numerous suggestions that improved the proposal, and advice.
* Greg Sanders for discussion, advice on fee management, and a number of suggestions that improved the proposal.
* John Moffett for early feedback and a test case demonstrating a recursive script evaluation attack.
* BL for discussion and insight.
* Johan Halseth for providing conceptual review and pointing out a pinning attack.
* Pieter Wuille for implementation advice.
